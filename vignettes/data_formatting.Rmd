---
title: "Data Formatting and Encoding"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data Formatting and Encoding}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.retina = 3,
  comment = "#>"
)
library(logitr)
# Read in results from already estimated models  so that the
# examples aren't actually run when building this page, otherwise it'll
# take much longer to build
mnl_pref_dannon <- readRDS(
  here::here('inst', 'extdata', 'mnl_pref_dannon.Rds'))
mnl_pref_weight <- readRDS(
  here::here('inst', 'extdata', 'mnl_pref_weight.Rds'))
mnl_pref_dummies <- readRDS(
  here::here('inst', 'extdata', 'mnl_pref_dummies.Rds'))
```

```{r, child=here::here('man', 'rmdchunks', 'header.Rmd')}
```

# Basic required format

```{r, child=here::here('man', 'rmdchunks', 'dataFormat.Rmd')}
```

The {logitr} package contains several example data sets that illustrate this data structure. For example, in the `yogurt` data set, each row is an alternative from a choice observation. Choice is identified by the `choice` column, the observation ID is identified by the `obsID` column, and the columns `price`, `feat`, and `brand` can be used as model covariates (brand is also broken out into additional dummy-coded columns):

```{r}
head(yogurt)
```

# Continuous versus discrete variables

Variables will be modeled as either continuous or discrete based on their data _type_.

**Numeric variables** are by default estimated with a single "slope" coefficient.

_Example_: Consider a data frame that contains a `price` variable with the following three levels: `c(10, 15, 20)`. Adding `price` to the `parNames` argument in the main `logitr()` function would result in a single `price` coefficient for the "slope" of the change in price.

**Categorical variables** (i.e. "character" or "factor" type variables) are by default estimated with a coefficient for all but the first "level", which serves as the "baseline" or `"0"` level. Categorical variables are automatically "dummy" coded: `0` for `FALSE` and `1` for `TRUE`.

_Example_: Consider a data frame that contains a `brand` variable with the following four levels: `c("dannon", "hiland", "weight", "yoplait")`. Adding `brand` to the `parNames` argument in the main `logitr()` function would result in three covariates: `brand_hiland`, `brand_weight`, and `brand_yoplait`, with `brand_dannon` serving as the reference level.

# Changing the reference level for categorical variables

If you include a categorical (factor or character type) variable in a model, it will by default be modeled as a categorical / discrete variable, and the default reference level is usually the alphabetically first level. For example, in the `yogurt` data, the `brand` variable has four levels: `"dannon"`, `"weight"`, `"hiland"`, and `"yoplait"`. Since `"dannon"` is alphabetically first, it will be set as the reference level:

```{r, eval=FALSE}
mnl_pref_dannon <- logitr(
  data       = yogurt,
  choiceName = 'choice',
  obsIDName  = 'obsID',
  parNames   = c('price', 'feat', 'brand')
)
```
```
Running Model...
Done!
```
```{r}
summary(mnl_pref_dannon)
```

If you want to modify that so that a different level is set as the reference, you need to modify the factor levels for that variable. The first level will be set as the reference level. For example, in the code below I set `"weight"` as the reference level for `brand`:

```{r, eval=FALSE}
yogurt$brand <- factor(yogurt$brand, levels = c(
  "weight", "hiland", "yoplait", "dannon"))
```

Now when the model is estimated, `"weight"` will be the reference level for `brand`:

```{r, eval=FALSE}
mnl_pref_weight <- logitr(
  data       = yogurt,
  choiceName = 'choice',
  obsIDName  = 'obsID',
  parNames   = c('price', 'feat', 'brand')
)
```
```
Running Model...
Done!
```
```{r}
summary(mnl_pref_weight)
```

Note how how the reference level is the `"weight"` brand whereas before it was the `"dannon"` brand.

# Creating dummy coded variables

If you wish to make dummy-coded variables yourself to use them in a model, I recommend using the `dummy_cols()` function from the [{fastDummies}](https://github.com/jacobkap/fastDummies) package. For example, in the code below, I create dummy-coded columns for the `brand` variable and then use those variables as covariates in a model:

```{r}
yogurt <- fastDummies::dummy_cols(yogurt, "brand")
```

The `yogurt` data frame now has new dummy-coded columns for brand (it actually already had these, but now there are additional ones):

```{r}
head(yogurt)
```

Now I can use those columns as covariates:

```{r, eval=FALSE}
mnl_pref_dummies <- logitr(
  data       = yogurt,
  choiceName = 'choice',
  obsIDName  = 'obsID',
  parNames   = c(
    'price', 'feat', 'brand_yoplait', 'brand_dannon', 'brand_weight')
)
```
```
Running Model...
Done!
```
```{r}
summary(mnl_pref_dummies)
```
