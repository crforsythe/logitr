head(tempData )
getTempData <- function(data, obsIDName, size) {
tempData <- data[which(data[obsIDName] < size),]
tempData$choice <- generateChoices(tempData, obsIDName, size)
return(tempData)
}
tempData <- getTempData(data, nobs[i])
tempData <- getTempData(data, obsIDName, nobs[i])
maxObs <- max(data[obsIDName])
nobs <- ceiling(seq(ceiling(maxObs/nbreaks), maxObs, length.out = nbreaks))
tempData <- getTempData(data, obsIDName, nobs[i])
dim(data )
head(data)
size
nobs
tempData <- data[which(data[obsIDName] < size),]
tempData
tempData$choice <- generateChoices(tempData, obsIDName, size)
getTempData <- function(data, obsIDName, size) {
tempData <- data[which(data[obsIDName] < size),]
tempData$choice <- generateChoices(tempData, obsIDName, size)
return(tempData)
}
tempData <- getTempData(data, obsIDName, nobs[i])
obsIDName
nobs[i]
i
i=1
tempData <- getTempData(data, obsIDName, nobs[i])
head(tempData )
dim(tempData)
# ============================================================================
# Functions for assessing sample size
# ============================================================================
#' Examine the standard errors from models before you collect choice data
#'
#' This function allows you to estimate a model on a design of experiment
#' that you have not yet used to collect data. This allows you to learn
#' about deficiencies in your design of experiment and also assess the sample
#' size needed to achieve parameter precision levels before you go out and
#' use the design to collect data. The function first determines the maximum
#' possible number of observations by taking the max of the "obsIDName"
#' argument. It then estimates a model
#' @keywords logitr, mnl, mxl, logit, sample size
#'
#' @export
#' @examples
#' # For an example go to: https://github.com/jhelvy/logitr/tree/master/example
sampleSizer = function(data, obsIDName, parNames, nbreaks=10, priceName=NULL,
randPars=NULL, randPrice=NULL, modelSpace='pref',
options=list()) {
maxObs <- max(data[obsIDName])
nobs <- ceiling(seq(ceiling(maxObs/nbreaks), maxObs, length.out = nbreaks))
models <- list()
for (i in 1:nbreaks) {
tempData <- getTempData(data, obsIDName, nobs[i])
model <- logitr(
data       = tempData,
choiceName = 'choice',
obsIDName  = obsIDName,
parNames   = parNames,
priceName  = priceName,
randPars   = randPars,
randPrice  = randPrice,
modelSpace = modelSpace,
options    = options)
models[[i]] <- getSE(model, i)
}
return(do.call(rbind, models))
}
getTempData <- function(data, obsIDName, size) {
tempData <- data[which(data[obsIDName] < size),]
tempData$choice <- generateChoices(tempData, obsIDName, size)
return(tempData)
}
generateChoices <- function(data, obsIDName, size) {
nrows <- table(data[obsIDName])
choices <- list()
for (i in 1:length(nrows)) {
choice <- rep(0, nrows[i])
choice[sample(seq(nrows[i]), 1)] <- 1
choices[[i]] <- choice
}
return(unlist(choices))
}
getSE <- function(model, size) {
se <- data.frame(
size = size,
se   = model$standErrs)
se$coef = row.names(se)
row.names(se) <- NULL
return(se)
}
# Install logitr package from github
library('devtools')
install_github('jhelvy/logitr')
# Load logitr package
library('logitr')
# Load the reformatted 'Yogurt' data set from the mlogit package
data(yogurt)
test <- sampleSizer(
data       = yogurt,
obsIDName  = 'obsID',
parNames   = c('price', 'feat', 'dannon', 'hiland', 'yoplait'),
nbreaks    = 5)
test
# ============================================================================
# Functions for assessing sample size
# ============================================================================
#' Examine the standard errors from models before you collect choice data
#'
#' This function allows you to estimate a model on a design of experiment
#' that you have not yet used to collect data. This allows you to learn
#' about deficiencies in your design of experiment and also assess the sample
#' size needed to achieve parameter precision levels before you go out and
#' use the design to collect data. The function first determines the maximum
#' possible number of observations by taking the max of the "obsIDName"
#' argument. It then estimates a model
#' @keywords logitr, mnl, mxl, logit, sample size
#'
#' @export
#' @examples
#' # For an example go to: https://github.com/jhelvy/logitr/tree/master/example
sampleSizer = function(data, obsIDName, parNames, nbreaks=10, priceName=NULL,
randPars=NULL, randPrice=NULL, modelSpace='pref',
options=list()) {
maxObs <- max(data[obsIDName])
nobs <- ceiling(seq(ceiling(maxObs/nbreaks), maxObs, length.out = nbreaks))
models <- list()
for (i in 1:nbreaks) {
tempData <- getTempData(data, obsIDName, nobs[i])
model <- logitr(
data       = tempData,
choiceName = 'choice',
obsIDName  = obsIDName,
parNames   = parNames,
priceName  = priceName,
randPars   = randPars,
randPrice  = randPrice,
modelSpace = modelSpace,
options    = options)
models[[i]] <- getSE(model, nobs[i])
}
return(do.call(rbind, models))
}
getTempData <- function(data, obsIDName, size) {
tempData <- data[which(data[obsIDName] < size),]
tempData$choice <- generateChoices(tempData, obsIDName, size)
return(tempData)
}
generateChoices <- function(data, obsIDName, size) {
nrows <- table(data[obsIDName])
choices <- list()
for (i in 1:length(nrows)) {
choice <- rep(0, nrows[i])
choice[sample(seq(nrows[i]), 1)] <- 1
choices[[i]] <- choice
}
return(unlist(choices))
}
getSE <- function(model, size) {
se <- data.frame(
size = size,
se   = model$standErrs)
se$coef = row.names(se)
row.names(se) <- NULL
return(se)
}
# Install logitr package from github
library('devtools')
install_github('jhelvy/logitr')
# Load logitr package
library('logitr')
# Load the reformatted 'Yogurt' data set from the mlogit package
data(yogurt)
test <- sampleSizer(
data       = yogurt,
obsIDName  = 'obsID',
parNames   = c('price', 'feat', 'dannon', 'hiland', 'yoplait'),
nbreaks    = 5)
test
plot(test$size, test$se)
plot
plot(test$size, test$se)
#' about deficiencies in your design of experiment and also assess the sample
#' size needed to achieve parameter precision levels before you go out and
#' use the design to collect data. The function first determines the maximum
#' possible number of observations by taking the max of the "obsIDName"
#' argument. It then estimates a model
#' @keywords logitr, mnl, mxl, logit, sample size
#'
#' @export
#' @examples
#' # For an example go to: https://github.com/jhelvy/logitr/tree/master/example
sampleSizer = function(data, obsIDName, parNames, nbreaks=10, plot=TRUE,
priceName=NULL, randPars=NULL, randPrice=NULL,
modelSpace='pref', options=list()) {
maxObs <- max(data[obsIDName])
nobs <- ceiling(seq(ceiling(maxObs/nbreaks), maxObs, length.out = nbreaks))
models <- list()
for (i in 1:nbreaks) {
tempData <- getTempData(data, obsIDName, nobs[i])
model <- logitr(
data       = tempData,
choiceName = 'choice',
obsIDName  = obsIDName,
parNames   = parNames,
priceName  = priceName,
randPars   = randPars,
randPrice  = randPrice,
modelSpace = modelSpace,
options    = options)
models[[i]] <- getSE(model, nobs[i])
}
result <- do.call(rbind, models)
if (plot) {
plot(result$size, result$se, ylab = 'Standard Error',
xlab = 'Number of observations')
}
return(result)
}
test <- sampleSizer(
data       = yogurt,
obsIDName  = 'obsID',
parNames   = c('price', 'feat', 'dannon', 'hiland', 'yoplait'),
nbreaks    = 5)
test <- sampleSizer(
data       = yogurt,
obsIDName  = 'obsID',
parNames   = c('price', 'feat', 'dannon', 'hiland', 'yoplait'),
nbreaks    = 10)
test <- sampleSizer(
data       = yogurt,
obsIDName  = 'obsID',
parNames   = c('price', 'feat', 'dannon', 'hiland', 'yoplait'),
nbreaks    = 10,
plot       = TRUE)
devtools::document()
# Install the package
devtools::install(force = TRUE)
# Load the package and view the summary
library(logitr)
# Install the package
devtools::install(force = TRUE)
# Load the package and view the summary
library(logitr)
help(package='logitr')
devtools::install_github('jhelvy/logitr')
devtools::install_github('jhelvy/logitr')
devtools::install_github('jhelvy/logitr')
devtools::install_github('jhelvy/logitr')
devtools::install_github('jhelvy/logitr')
# Load libraries
library(logitr)
library(ggplot2)
# Load Functions
getMultistartPars = function(model) {
allModels = model$models
coefs     = coef(model$bestModel)
startPars = c()
for (i in 1:length(allModels)) {
startPars = c(startPars, allModels[[i]]$startPars)
}
pars = data.frame(
startPar = startPars,
coef     = rep(coefs, length(allModels)))
pars$parName = rep(names(coefs), length(allModels))
pars$run     = rep(seq(length(allModels)), each=length(coefs))
return(pars)
}
plotMultistartPars = function(model) {
pars = getMultistartPars(model)
plot = ggplot(pars,
aes(x=parName, y=startPar)) +
geom_point(color='blue') +
geom_errorbar(aes(ymax=coef, ymin=coef), color="#AA0000")
return(plot)
}
# Estimate a MNL model in the WTP Space using a multistart:
data(yogurt)
model = logitr(
data       = yogurt,
choiceName = 'choice',
obsIDName  = 'obsID',
parNames   = c('feat', 'dannon', 'hiland', 'yoplait'),
priceName  = 'price',
modelSpace = 'wtp',
options = list(
numMultiStarts = 20,
keepAllRuns    = TRUE,
startParBounds = c(-10, 10)))
plotMultistartPars(model)
plotMultistartPars = function(model) {
pars = getMultistartPars(model)
plot = ggplot(pars,
aes(x = parName, y = startPar)) +
geom_point(color = 'blue') +
geom_errorbar(aes(ymax = coef, ymin = coef), color = "#AA0000") +
theme_minimal()
return(plot)
}
plotMultistartPars(model)
plotMultistartPars = function(model) {
pars = getMultistartPars(model)
plot = ggplot(pars,
aes(x = parName, y = startPar)) +
geom_point(color = 'blue') +
geom_errorbar(aes(ymax = coef, ymin = coef), color = "#AA0000") +
theme_bw()
return(plot)
}
plotMultistartPars(model)
pars = getMultistartPars(model)
pars
plotMultistartPars = function(model) {
pars = getMultistartPars(model)
plot = ggplot(pars,
aes(x = parName, y = startPar)) +
geom_point(color = 'blue') +
geom_errorbar(aes(ymax = coef, ymin = coef), color = "#AA0000") +
theme_bw() +
labs(x = "Parameter name",
y = "Starting parameter",
title = "Comparison of starting parameters (blue points) to\nbest coefficient estimate (red lines)")
return(plot)
}
plotMultistartPars(model)
# Create the documentation for the package
devtools::document()
# Install the package
devtools::install(force = TRUE)
library('logitr')
head(yogurt)
head(yogurt)
# Run a MNL model in the Preference Space:
mnl.pref = logitr(
data       = yogurt,
choiceName = 'choice',
obsIDName  = 'obsID',
parNames   = c('price', 'feat', 'dannon', 'hiland', 'yoplait'))
# Print a summary of the results:
summary(mnl.pref)
# Get the coefficients from the model:
coef(mnl.pref)
summary(mnl.pref)
coef(mnl.pref)
coef(mnl.pref)
# Get the WTP implied from the preference space model
mnl.pref.wtp = wtp(mnl.pref, priceName = 'price')
mnl.pref.wtp
# Get the WTP implied from the preference space model
mnl_pref_wtp = wtp(mnl_pref, priceName = 'price')
mnl_pref_wtp
# Load logitr package
library('logitr')
# Preview the reformatted 'Yogurt' data set from the mlogit package
head(yogurt)
# Run a MNL model in the Preference Space:
mnl_pref = logitr(
data       = yogurt,
choiceName = 'choice',
obsIDName  = 'obsID',
parNames   = c('price', 'feat', 'dannon', 'hiland', 'yoplait'))
# Print a summary of the results:
summary(mnl_pref)
# Get the coefficients from the model:
coef(mnl_pref)
# Get the WTP implied from the preference space model
mnl_pref_wtp = wtp(mnl_pref, priceName = 'price')
mnl_pref_wtp
# Run a MNL model in the WTP Space using a multistart:
mnl_wtp = logitr(
data       = yogurt,
choiceName = 'choice',
obsIDName  = 'obsID',
parNames   = c('feat', 'dannon', 'hiland', 'yoplait'),
priceName  = 'price',
modelSpace = 'wtp',
options = list(
# Since WTP space models are non-convex, run a multistart:
numMultiStarts = 10,
# If you want to view the results from each multistart run,
# set keepAllRuns=TRUE:
keepAllRuns = TRUE,
# Use the computed WTP from the preference space model as the starting
# values for the first run:
startVals = mnl_pref_wtp$Estimate,
# Because the computed WTP from the preference space model has values
# as large as 8, I increase the boundaries of the random starting values:
startParBounds = c(-5,5)))
# Print a summary of all multistart runs and a summary of the best model:
summary(mnl_wtp)
summary(mnl_wtp$models[[3]])
# Print a summary of the best model:
summary(mnl_wtp$bestModel)
# Get the coefficients from the model:
coef(mnl_wtp)
wtpCompare(mnl_pref, mnl_wtp, priceName = 'price')
# Create a set of alternatives for which to simulate shares. Each row is an
# alternative and each column an attribute. In this example, I just use one of the choice observations from the yogurt dataset:
alts = subset(yogurt, obsID == 42,
select=c('feat', 'price', 'dannon', 'hiland', 'yoplait'))
row.names(alts) = c('dannon', 'hiland', 'weight', 'yoplait')
alts
market = subset(yogurt, obsID == 42,
select = c('feat', 'price', 'dannon', 'hiland', 'yoplait'))
row.names(market) = c('dannon', 'hiland', 'weight', 'yoplait')
market
# Create a set of alternatives for which to simulate shares. Each row is an
# alternative and each column an attribute. In this example, I just use one
# of the choice observations from the yogurt dataset:
market = subset(yogurt, obsID == 42,
select = c('feat', 'price', 'dannon', 'hiland', 'yoplait'))
row.names(market) = c('dannon', 'hiland', 'weight', 'yoplait')
market
# Run the simulation using the preference space MNL model:
mnl_pref_simulation = simulateShares(mnl_pref, market, alpha = 0.025)
mnl_pref_simulation
# Create the documentation for the package
devtools::document()
# Install the package
devtools::install(force = TRUE)
# # Install logitr package from github
# library('devtools')
# install_github('jhelvy/logitr')
# Load logitr package
library('logitr')
# Preview the reformatted 'Yogurt' data set from the mlogit package
head(yogurt)
# ============================================================================
# Estimate Homogeneous MNL models
# Run a MNL model in the Preference Space:
mnl_pref = logitr(
data       = yogurt,
choiceName = 'choice',
obsIDName  = 'obsID',
parNames   = c('price', 'feat', 'dannon', 'hiland', 'yoplait'))
# Print a summary of the results:
summary(mnl_pref)
# Get the coefficients from the model:
coef(mnl_pref)
# Get the WTP implied from the preference space model
mnl_pref_wtp = wtp(mnl_pref, priceName = 'price')
mnl_pref_wtp
# Run a MNL model in the WTP Space using a multistart:
mnl_wtp = logitr(
data       = yogurt,
choiceName = 'choice',
obsIDName  = 'obsID',
parNames   = c('feat', 'dannon', 'hiland', 'yoplait'),
priceName  = 'price',
modelSpace = 'wtp',
options = list(
# Since WTP space models are non-convex, run a multistart:
numMultiStarts = 10,
# If you want to view the results from each multistart run,
# set keepAllRuns=TRUE:
keepAllRuns = TRUE,
# Use the computed WTP from the preference space model as the starting
# values for the first run:
startVals = mnl_pref_wtp$Estimate,
# Because the computed WTP from the preference space model has values
# as large as 8, I increase the boundaries of the random starting values:
startParBounds = c(-5, 5)))
# Print a summary of all multistart runs and a summary of the best model:
summary(mnl_wtp)
# Print a summary of only the third model run:
summary(mnl_wtp$models[[3]])
# Print a summary of the best model:
summary(mnl_wtp$bestModel)
# Get the coefficients from the model:
coef(mnl_wtp)
# CHECKING FOR LOCAL MINIMA IN WTP SPACE MODELS:
# Comparing the WTP and log-likelihood values between the equivalent models in
# the preference space and WTP space is a helpful check for whether you have
# reached a global solution in WTP space models, which have non-convex
# log-likelihoods functions. This can be done using the wtpCompare function:
wtpCompare(mnl_pref, mnl_wtp, priceName = 'price')
market = subset(yogurt, obsID == 42,
select = c('feat', 'price', 'dannon', 'hiland', 'yoplait'))
row.names(market) = c('dannon', 'hiland', 'weight', 'yoplait')
market
# Run the simulation using the preference space MNL model:
mnl_pref_simulation = simulateShares(mnl_pref, market, alpha = 0.025)
mnl_pref_simulation
# Run the simulation using the WTP space MNL model:
mnl_wtp_simulation = simulateShares(mnl_wtp, market, priceName = 'price')
mnl_wtp_simulation
# Plot simulation results from preference space MNL model:
library(ggplot2)
mnl_pref_simulation$alt = row.names(mnl_pref_simulation)
ggplot(mnl_pref_simulation, aes(x = alt, y = share_mean)) +
geom_bar(stat = 'identity', width = 0.7) +
geom_errorbar(aes(ymin = share_low, ymax = share_high), width = 0.2) +
scale_y_continuous(limits = c(0, 1)) +
labs(x='Alternative', y='Expected Share') +
theme_bw()
ggplot(mnl_pref_simulation, aes(x = alt, y = share_mean)) +
geom_bar(stat = 'identity', width = 0.7, fill = "dodgerblue") +
geom_errorbar(aes(ymin = share_low, ymax = share_high), width = 0.2) +
scale_y_continuous(limits = c(0, 1)) +
labs(x='Alternative', y='Expected Share') +
theme_bw()
market
mnl_pref_simulation
test <- sampleSizer(
data       = yogurt,
obsIDName  = 'obsID',
parNames   = c('price', 'feat', 'dannon', 'hiland', 'yoplait'),
nbreaks    = 10,
plot       = TRUE)
test
